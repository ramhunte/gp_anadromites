---
title: "cost_rp"
author: "Ray Hunter"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, include=FALSE, message = FALSE, error = FALSE)


#clearing environment
rm(list = ls())

#sourcing data
source("../common.R")
```



### 1) IMPACT OF SITE ACCESSIBILITY AND MATERIALS ON COSTS

## 1.1) SITE ACCESSABILITY: FIND THE NEAREST ROAD TO EACH STREAM REACH and ASSIGN LMH (STOLEN FROM ELJ)
```{r}
# Create sf objects
sf_roads <- st_as_sf(roads_stl)
sf_streamreaches <- st_as_sf(flow_stl, coords = c("lon", "lat"), crs = 4326)

# Check and match CRS
if (!identical(st_crs(sf_roads), st_crs(sf_streamreaches))) {
  sf_roads <- st_transform(sf_roads, st_crs(sf_streamreaches))
}
# Find the distance from each stream to the nearest road
distances <- st_distance(sf_streamreaches, sf_roads)

# Extract the minimum distance for each stream reach
min_distances <- apply(distances, 1, min)

# Add the distances to the original data.frame
flow_stl$distance_to_nearest_road_m <- min_distances
flow_stl$distance_to_nearest_road_mi <- flow_stl$distance_to_nearest_road_m *0.000621371


#inspecting
min(flow_stl$distance_to_nearest_road_mi)
max(flow_stl$distance_to_nearest_road_mi)
hist(flow_stl$distance_to_nearest_road_mi)

# Print the resulting data.frame
print(flow_stl$distance_to_nearest_road_mi)

# Check the CRS of sf_streamreaches
crs_streamreaches <- st_crs(flow_stl)
print(crs_streamreaches$units)

# make a column assigning low, medium or high distance depending on the numerical distance to nearest road

create_transportation_column <- function(distance_column) {
  transportation_column <- cut(
    distance_column,
    breaks = c(-Inf, 7, 20, Inf),
    labels = c("low", "medium", "high"),
    include.lowest = TRUE
  )
  return(transportation_column)
}

# Apply the function to create the 'transportation' column (all are low)
flow_stl$transportation <- create_transportation_column(flow_stl$distance_to_nearest_road_mi)
```


## 1.2) MATERIALS: STREAM ENERGY USED TO CALCULATE MATERIALS COSTS (STOLEN FROM ELJ)
```{r}

flow_stl$slope_perc<-flow_stl$slope*100
flow_stl$slope_degrees <- atan(flow_stl$slope_perc / 100) * (180 / pi)


# Create a function to assign energy values based on slope and wint_width ranges
assign_energy_width <- function(input_df, low_slope_range, medium_slope_range, high_slope_range, low_wint_width_range, medium_wint_width_range, high_wint_width_range, slope) {
  # # Filter for hab_unit == Marsh
  # filtered_df <- input_df %>% filter(hab_unit == "Marsh")
  
  # Create a new column "energy" based on conditions
  filtered_df <- input_df %>%
    mutate(energy = case_when(
      # low slope, low range
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) |
      # medium slope, low width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) |
      # low slope, medium width
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2]) 
      ~ "low",
      # low slope, high width
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # medium slope, medium width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2]) |
      # high slope, low width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2])
       ~ "medium",
      # high slope, high width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # medium slope, high width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # high slope, medium width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2])
       ~ "high",
      TRUE ~ "Unknown"  # Handle any other cases
    ))
  
  return(filtered_df)
}

# Call the function with the provided dataframe and numeric range bounds
low_slope_range <- c(0, 10)
medium_slope_range <- c(10.0000000001, 20)
high_slope_range <- c(20.0000000001, 1000) #arbitrary large number
low_width_range <- c(0, 20)
medium_width_range <- c(20.0000000001, 40)
high_width_range <- c(40.0000000001, 300) #arbitrary large number

flow_stl <- assign_energy_width(flow_stl, low_slope_range, medium_slope_range, high_slope_range, low_width_range, medium_width_range, high_width_range, slope_degrees)

unique(flow_stl$energy)
```



## 1.3) CALCULATE RELATIVE COST BASED ON MATERIALS (ENERGY) AND SITE ACCESSABILITY (TRANSPORTATION) (STOLEN FROM ELJ)
```{r}
#energy column is called energy (low, medium and high) and transportation is distance_to_nearest_road_mi (values are low, medium and high)

calculate_intermediate_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      relative_cost = case_when(
        transportation == "low" & energy == "low" |
        transportation == "low" & energy == "medium" ~ "low",
        transportation == "low" & energy == "high" |
        transportation == "medium" & energy == "low" |
        transportation == "medium" & energy == "medium" ~ "medium",
        transportation == "medium" & energy == "high" |
        transportation == "high" & energy == "low" |
        transportation == "high" & energy == "medium" |
        transportation == "high" & energy == "high" ~ "high",
        # Add more conditions for other combinations here
        TRUE ~ "Unknown"  # Default value if no conditions match
      )
    )
  
  return(input_df)
}
  flow_stl <- calculate_intermediate_cost(flow_stl)

```


#####################################################################################################

### 2) COST OF RIPARIAN PLANTING PROJECTS ($/acre)

```{r}
## matrix with levels of site preparation ( average slope ) and output from materials/accessibility 
# need to measure the average slope around a stream within 50m 
```

#### 2.1) LEVEL OF SITE PREPARATION 

```{r}
                     
# importing elevation raster data
# Data: https://gis.ess.washington.edu/data/raster/tenmeter/byquad/info.html


# listing the dem elevation files 
elev_list <- list.files(path = "/Users/rayhunter/Desktop/GP/gp_anadromites/data/elevation", "dem$", 
                   full.names = TRUE)

#  rasterizing elevation dem files and storing them in a collection 
elev_list_rast <- sprc(lapply(elev_list, rast))

# combining rasters into 1 mosaic
elev_mos <- mosaic(elev_list_rast)

#calculating slope from elevation data
full_slope <- terrain(x = elev_mos, v = "slope", unit = "degrees")
plot(full_slope)

# projecting NAD83 (which is more accurate and used by the NOAA files) onto raster data (originally using NAD27)  
full_slope <- project(full_slope, "EPSG:26910")

# writeLines(crs(flow_buff))
# writeLines(crs(full_slope))

# creating a 50m buffer around stream edges
flow_buff <- st_buffer(flow_stl, dist = 50, endCapStyle = "FLAT")

# cropping and masking slope raster data to stream buffer
crop_rast <- crop(full_slope, flow_buff, mask = TRUE)
plot(crop_rast)

#extract mean 
extract <- extract(crop_rast, flow_buff, fun = mean)

#joining to original flow_stl 
flow_stl <- flow_stl %>% 
  mutate(avg_bank_slope = extract$slope)



hist(flow_buff$avg_slope)

# calculate the average slope in degrees w/ in a 50m buffer of each reach 

# buff_rast <- rasterize(vect(flow_buff),
#                       crop_rast,
#                       field = "noaaid")
# 
# slope_zonal <- zonal(crop_rast,
#                   buff_rast,
#                   fun = "mean",
#                   na.rm = TRUE)
#
# avg_slope <- left_join(flow_buff,
#                          slope_zonal, 
#                        by = "noaaid") %>% 
#   rename(avg_slope = slope.y)

# #trying to figure out why there are NA values in small buffer polygons 
# 
# avg_slope2 <- avg_slope %>% 
#   filter(is.na(avg_slope))



######## CLASSIFY SLOPE LOW, MED, HIGH ########

low_slope <- c(0, 10)
med_slope <- c(10.001, 20)
high_slope <- c(20.001, Inf)


bank_slope_cost_fun <- function(slope) {
  bank_slope_class <- ifelse(slope > 0 & slope <= 10, "low",
                ifelse(slope > 10 & slope <= 20, "med", "high"))
  return(bank_slope_class)
}

flow_stl <- flow_stl %>%
  mutate(bank_slope_class = bank_slope_cost_fun(avg_slope))


```


### INSPECTING DATA ON MAP ###
```{r}
# # plotting raster as a df so that it can be plotted in ggplot 
# # computationally expensive, so only run if needed 

# elev_mos_df <- as.data.frame(elev_mos, xy = TRUE)


ggplot() +
  # # ggplotting raster layer (only run if needed)
  # geom_raster(data = elev_mos_df, aes(x = x, y = y, fill = q525)) +
  # geom_sf(data = flow_buff, color = "red") +
  geom_sf(data = flow_buff, aes(col = avg_slope)) +
  scale_color_viridis_c() +
  # geom_sf(data = flow_stl, color = "red") +
  
  # geom_sf(data = flood_sf, aes(fill = Period)) + 
  theme_minimal() 
  # labs(title = "Stillaguamish Basin", color = "Stream type", fill = "Wetland Status")
```


### 3) COST OF RIPARIAN PLANTING PROJECTS 
### MATERIALS/SITE ACCESSIBILITY X SITE PREPARATION

```{r}
rp_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      #creating a column for low end of cost spectrum 
      lower_cost = case_when(
        intermediate_cost == "low" & bank_slope_class == "low" ~ 5000,
        intermediate_cost == "low" & bank_slope_class == "medium" ~ 20000,
        intermediate_cost == "low" & bank_slope_class == "high" ~ 60000,
        intermediate_cost == "medium" & bank_slope_class == "low" ~ 10000,
        intermediate_cost == "medium" & bank_slope_class == "medium" ~ 45000,
        intermediate_cost == "medium" & bank_slope_class == "high" ~ 70000,
        intermediate_cost == "high" & bank_slope_class == "low" ~ 30000,
        intermediate_cost == "high" & bank_slope_class == "medium" ~ 55000,
        intermediate_cost == "high" & bank_slope_class == "high" ~ 100000,
        # Add more conditions for other combinations here
        TRUE ~ 0  # Default value if no conditions match
      ),
      #creating a column for high end of cost spectrum 
      upper_cost = case_when(
       intermediate_cost == "low" & bank_slope_class == "low" ~ 25000,
        intermediate_cost == "low" & bank_slope_class == "medium" ~ 50000,
        intermediate_cost == "low" & bank_slope_class == "high" ~ 100000,
        intermediate_cost == "medium" & bank_slope_class == "low" ~ 35000,
        intermediate_cost == "medium" & bank_slope_class == "medium" ~ 65000,
        intermediate_cost == "medium" & bank_slope_class == "high" ~ 120000,
        intermediate_cost == "high" & bank_slope_class == "low" ~ 50000,
        intermediate_cost == "high" & bank_slope_class == "medium" ~ 80000,
        intermediate_cost == "high" & bank_slope_class == "high" ~ 135000,
        # Add more conditions for other combinations here
        TRUE ~ 0  # Default value if no conditions match
      )
    )
  
  return(input_df)
}

rp_cost_final <- rp_cost(intermediate_cost)
```



#### NEXT STEPS: 
* Problem: all relative costs are low b/c transportation is all "low" and energy is all "low" or "medium"
* need to figure out how many acres along each stream need to be restored
  - cost estimates are given in $/acre. Literature says at least 30m inland
  - maybe multiple winter stream width by 25%? both sides of stream?
* how many acres along each side of the stream are being restored?
















