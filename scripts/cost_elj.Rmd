---
title: "cost_elj"
author: "Meghan Roberts"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#clearing environment
#rm(list = ls())
#sourcing data
source("../common.R")
source("functions.R")
```

## LOADING IN THE ROAD DATA/GETTING IT SMALL ENOUGH TO GO ON GITHUB
```{r}
# roads <- st_read(here("data", "roads", "WA_roads.gpkg"))
# #print(roads)
# ## no need to run this ever again
# roads <-roads %>% select("OBJECTID", "NAME")
# st_write(roads, here("data/roads/WA_roads_thin.gpkg"))
```

## FIND THE NEAREST ROAD TO EACH STREAM REACH and ASSIGN LMH
# only run once and then just load in the flow_stl_mod
```{r}
# # # Create sf objects
#  sf_roads <- st_as_sf(roads_stl)
#  sf_streamreaches <- st_as_sf(flow_stl, coords = c("lon", "lat"), crs = 4326)
# #
# # # Check and match CRS
#  if (!identical(st_crs(sf_roads), st_crs(sf_streamreaches))) {
#    sf_roads <- st_transform(sf_roads, st_crs(sf_streamreaches))
#  }
# # # Find the distance from each stream to the nearest road
#  distances <- st_distance(sf_streamreaches, sf_roads)
# #
# # # Extract the minimum distance for each stream reach
#  min_distances <- apply(distances, 1, min)
# #
# # # Add the distances to the original data.frame
#  flow_stl$distance_to_nearest_road_m <- min_distances
#  flow_stl$distance_to_nearest_road_mi <- flow_stl$distance_to_nearest_road_m *0.000621371
# #
#  min(flow_stl$distance_to_nearest_road_mi)
#  max(flow_stl$distance_to_nearest_road_mi)
#  hist(flow_stl$distance_to_nearest_road_mi)
# #
# # # Print the resulting data.frame
#  print(flow_stl$distance_to_nearest_road_mi)
# #
# # # Check the CRS of sf_streamreaches
#  crs_streamreaches <- st_crs(flow_stl)
#  print(crs_streamreaches$units)
# #
# # # make a column assigning low, medium or high distance depending on the numerical distance to nearest road
# #
# create_transportation_column <- function(distance_column) {
#    transportation_column <- cut(
#      distance_column,
#      breaks = c(-Inf, 0.25, 0.75, Inf),
#      labels = c("low", "medium", "high"),
#      include.lowest = TRUE
#    )
#    return(transportation_column)
#  }
# #
# # # Apply the function to create the 'transportation' column (all are low)
#  flow_stl$transportation <- create_transportation_column(flow_stl$distance_to_nearest_road_mi)
#  transportation_info<-flow_stl %>% select(c(noaaid, transportation)) %>% st_drop_geometry()
#  write.csv(transportation_info, here("data", "HARP", "stl_transportation.csv"), row.names=FALSE)
# 
# # #### load in csv file and join to flow_stl
#  flow_stl_mod<-full_join(flow_stl, transportation_stl)



```

Function that assigns an energy value to the streams
```{r}

flow_stl<-assign_energy_width(flow_stl)

unique(flow_stl$energy)
#unknown is in the delta
```
## FILTER TO REACHES WHERE WOOD IS A BENEFIT
```{r}
#only keep reaches where there is a benefit of wood to chinook
stilly_bens_filtered<-stilly_bens %>% filter(pop=="fall_chinook" & perc_change>0 & scenario=="Wood")
wood_ben_basin<-unique(stilly_bens_filtered$subbasin_num)
wood_ben_basin<-as.data.frame(wood_ben_basin) %>% rename("subbasin_n"="wood_ben_basin")
wood_ben_basin$subbasin_n<-as.character(wood_ben_basin$subbasin_n)
flow_stl_wood<-left_join(wood_ben_basin, flow_stl, by="subbasin_n")
```

## WRITE A FUNCTION THAT GIVES RELATIVE COST BASED ON ENERGY (materials) AND TRANSPORTATION
##### INTERMEDIATE COST
```{r}
#energy column is called energy (low, medium and high) and transportation is distance_to_nearest_road_mi (values are low, medium and high)

calculate_intermediate_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      relative_cost = case_when(
        transportation == "low" & energy == "low" |
        transportation == "low" & energy == "medium" ~ "low",
        transportation == "low" & energy == "high" |
        transportation == "medium" & energy == "low" |
        transportation == "medium" & energy == "medium" ~ "medium",
        transportation == "medium" & energy == "high" |
        transportation == "high" & energy == "low" |
        transportation == "high" & energy == "medium" |
        transportation == "high" & energy == "high" ~ "high",
        # Add more conditions for other combinations here
        TRUE ~ "Unknown"  # Default value if no conditions match
      )
    )
  
  return(input_df)
}
  intermediate_cost <- calculate_intermediate_cost(flow_stl_wood)

```

## WRITE A FUNCTION THAT GIVES COST RANGES BASED ON PREVIOUS COST FUNCTION AND STREAM FLOW RATE
```{r}
calculate_final_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      lower_cost_estimate = case_when(
        relative_cost == "low" & energy == "low" ~ 10000,
        relative_cost == "low" & energy == "medium" ~ 20000,
        relative_cost == "low" & energy == "high" ~ 10000,
        relative_cost == "medium" & energy == "low" ~ 20000,
        relative_cost == "medium" & energy == "medium" ~ 15000,
        relative_cost == "medium" & energy == "high" ~ 40000,
        relative_cost == "high" & energy == "low" ~ 20000,
        relative_cost == "high" & energy == "medium" ~ 40000,
        relative_cost == "high" & energy == "high" ~ 60000,
        TRUE ~ 0  # Default value if no conditions match
      ),
      upper_cost_estimate = case_when(
        relative_cost == "low" & energy == "low" ~ 30000,
        relative_cost == "low" & energy == "medium" ~ 50000,
        relative_cost == "low" & energy == "high" ~ 20000,
        relative_cost == "medium" & energy == "low" ~ 50000,
        relative_cost == "medium" & energy == "medium" ~ 45000,
        relative_cost == "medium" & energy == "high" ~ 60000,
        relative_cost == "high" & energy == "low" ~ 40000,
        relative_cost == "high" & energy == "medium" ~ 70000,
        relative_cost == "high" & energy == "high" ~ 80000,
        TRUE ~ 0  # Default value if no conditions match
      )
    )
  
  return(input_df)
}

elj_no_inf_cost <- calculate_final_cost(intermediate_cost)
```

## APPLY PRODUCER PRICE INDICES TO COST RANGES
```{r}
#apply inflation and then par down the dataframe
elj_cost<-elj_no_inf_cost %>% 
  mutate(lower_cost_estimate=lower_cost_estimate*ppi,
           upper_cost_estimate=upper_cost_estimate*ppi) 
```

## CREATE A NEW FUNCTION THAT ADDRESS PROBLEM WITH $/MILE AND $/STRUCTURE
## APPLY THE COST PER ACRE TO MILES OF STREAM
  # units of the above function are in $/stream mile (Ranges given by per stream mile (assuming 100-400 pieces per stream mile.) All other cells ranges given per structure.
All costs ranges assume purchased material.)
50% restored for $/stream mile cases
assume 1 project per 500 meter reach for those that are $/structure

```{r}
elj_cost <- elj_cost %>%
  rowwise() %>%
  mutate(
    final_lower_cost = ifelse((relative_cost == 'low' && energy == 'low') || (relative_cost == 'medium' && energy == 'low') || (relative_cost == 'low' && energy == 'medium'),
                              lower_cost_estimate * length * 0.000621371 * 0.5,
                              lower_cost_estimate * length * ifelse(energy == 'low', 1/100, ifelse(energy == 'medium', 1/200, ifelse(energy == 'high', 1/400, 1)))
    ),
    
    final_upper_cost = ifelse((relative_cost == 'low' && energy == 'low') || (relative_cost == 'medium' && energy == 'low') || (relative_cost == 'low' && energy == 'medium'),
                              upper_cost_estimate * length * 0.000621371 * 0.5,
                              upper_cost_estimate * length * ifelse(energy == 'low', 1/100, ifelse(energy == 'medium', 1/200, ifelse(energy == 'high', 1/400, 1)))
    )
  )


elj_cost$avg_cost<-(elj_cost$final_lower_cost+elj_cost$final_upper_cost)/2
```


```{r}
# #checking if any streams fall into the category that I would need to consider $/structure
# unique(elj_cost[c("relative_cost", "energy")])
# #convert reach length from meters to miles
# elj_cost$length_mi<-elj_cost$length*0.000621371
# #multiply miles by $/mile to get total dollars
# #also only apply ELJ costs to 50% of the stream mileage
# elj_cost$final_lower_cost<-elj_cost$lower_cost_estimate*elj_cost$length_mi*0.5
# elj_cost$final_upper_cost<-elj_cost$upper_cost_estimate*elj_cost$length_mi*0.5
# elj_cost$avg_cost<-(elj_cost$final_lower_cost+elj_cost$final_upper_cost)/2
```

## FIND THE COST PER SUBBASIN
```{r}
#filtering the benefits
#include only subbasins that have a benefit to chinook, but retain rows for other pops
stilly_bens_wood_subba <- stilly_bens %>% filter(scenario=="Wood" & pop == "fall_chinook" & perc_change > 0) %>% select(subbasin) %>% unique()
#join this to stilly_bens and filter for wood sceario
stilly_bens_wood<-left_join(stilly_bens_wood_subba, stilly_bens) %>% filter(scenario=="Wood") %>% drop_na()

#calculating final cost riparian planting by subbasin 
elj_cost_subbasin <- elj_cost %>%
  #dropping stream geometries
  st_drop_geometry() %>% 
  #grouping by subbasin
  group_by(noaa_subba) %>% 
  #adding up all lower cost ranges for reach costs by subbasin 
  summarize(total_lower_cost = sum(final_lower_cost),
            total_upper_cost = sum(final_upper_cost),
            total_avg_cost = (total_lower_cost + total_upper_cost)/2) %>% 
  #joining with subs_stl to get the geometries of the subbasins
  right_join(subs_stl[,1] ) %>% 
  #add subbasin salmon ppltn projected and current %>% 
  left_join(stilly_bens_wood %>% 
              select(subbasin, n, n_curr, perc_change, pop), by = c("noaa_subba" = "subbasin")) %>% 
  # finding increased increased fish from intervention
  mutate(n_diff = n - n_curr,
         #creating an annual cost benefit ratio 
         cb_ratio = ann_cost_ben(C = total_avg_cost, f = n_diff)) %>% 
  #reassigning it as sf b/c geometries became empty after le
  st_as_sf()

bens_filter_elj <- elj_cost_subbasin %>% 
  filter(pop == "fall_chinook" & n_diff >= 1)

elj_cost_subbasin <- elj_cost_subbasin %>% 
  filter(noaa_subba %in% bens_filter_elj$noaa_subba)


st_write(elj_cost_subbasin , here("data", "final_dfs", "elj_costs.gpkg"), append = FALSE)
```

## MAP THE RESULTS
```{r}
#convert to sf for mapping purposes
elj_cost_sf <- st_as_sf(elj_cost)%>% 
  select(noaaid,final_lower_cost, final_upper_cost, avg_cost, noaa_subba)
ggplot() +
  geom_sf(data = subs_stl, aes()) +
  geom_sf(data = elj_cost_sf, aes(color = avg_cost)) + #use color, not fill bc line
  scale_color_viridis_c(breaks = c(0, 2000, 4000, 6000), option = "E", name = "Average Cost ($)", direction=-1)+
  theme_minimal()
```


<!-- #incorporate benefits into df (from benefit_data) -->
<!-- ```{r} -->

<!-- elj_cost_ben <- full_join(elj_cost_sf, elj_bens, by = c("noaa_subba" = "subbasin")) -->
<!-- #calculate cost benefit ratio -->
<!-- elj_cost_ben$n_diff<-elj_cost_ben$n-elj_cost_ben$n_curr -->
<!-- elj_cost_ben$ratio_n<-elj_cost_ben$avg_cost/(elj_cost_ben$n_diff) -->
<!-- elj_cost_ben <- elj_cost_ben %>% -->
<!--   mutate(ratio_n_log = if_else(!is.na(ratio_n) & ratio_n != 0, log(ratio_n),NA_real_)) -->
<!-- write.csv(elj_cost_ben, here("data", "final_dfs", "elj_costs.csv")) -->
<!-- ``` -->

