---
title: "cost_elj"
author: "Meghan Roberts"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#clearing environment
rm(list = ls())
#sourcing data
source("../common.R")
```

## LOADING IN THE ROAD DATA/GETTING IT SMALL ENOUGH TO GO ON GITHUB
```{r}
#print(roads)
## no need to run this ever again
# roads <-roads %>% select("OBJECTID", "NAME")
# st_write(roads, here("data/Washington_data/WA_roads_thin.gpkg"))
```

## FIND THE NEAREST ROAD TO EACH STREAM REACH and ASSIGN LMH
```{r}
# Create sf objects
sf_roads <- st_as_sf(roads_stl)
sf_streamreaches <- st_as_sf(flow_stl, coords = c("lon", "lat"), crs = 4326)

# Check and match CRS
if (!identical(st_crs(sf_roads), st_crs(sf_streamreaches))) {
  sf_roads <- st_transform(sf_roads, st_crs(sf_streamreaches))
}
# Find the distance from each stream to the nearest road
distances <- st_distance(sf_streamreaches, sf_roads)

# Extract the minimum distance for each stream reach
min_distances <- apply(distances, 1, min)

# Add the distances to the original data.frame
flow_stl$distance_to_nearest_road_m <- min_distances
flow_stl$distance_to_nearest_road_mi <- flow_stl$distance_to_nearest_road_m *0.000621371

min(flow_stl$distance_to_nearest_road_mi)
max(flow_stl$distance_to_nearest_road_mi)
hist(flow_stl$distance_to_nearest_road_mi)

# Print the resulting data.frame
print(flow_stl$distance_to_nearest_road_mi)

# Check the CRS of sf_streamreaches
crs_streamreaches <- st_crs(flow_stl)
print(crs_streamreaches$units)

# make a column assigning low, medium or high distance depending on the numerical distance to nearest road

create_transportation_column <- function(distance_column) {
  transportation_column <- cut(
    distance_column,
    breaks = c(-Inf, 7, 20, Inf),
    labels = c("low", "medium", "high"),
    include.lowest = TRUE
  )
  return(transportation_column)
}

# Apply the function to create the 'transportation' column (all are low)
flow_stl$transportation <- create_transportation_column(flow_stl$distance_to_nearest_road_mi)
```

## STOLEN FROM FLOODPLAIN

Check distribution of slopes and wint_width
```{r}
## Make histogram of slope
hist(flow_stl$slope, main = "Histogram of Slope Column", xlab = "Slope Values")
# Calculate quantiles to split data into three equal sections
quantiles_slope <- quantile(flow_stl$slope, probs = c(1/3, 2/3), na.rm = TRUE)
quantiles_slope

## Define values for low, medium and high based on histogram
## Low <0.0038
## Medium >0.00381 and <0.0214
## High >0.0215
## Make histogram of width
hist(flow_stl$wint_width, main = "Histogram of Width Column", xlab = "Width Values")
quantiles_width <- quantile(flow_stl$wint_width, probs = c(1/3, 2/3), na.rm = TRUE)
quantiles_width
## Define values for low, medium and high based on histogram
## Low <3.394
## Medium >3.395 and <11.288
## High >11.289
```

## ALSO STOLEN FROM FLOODPLAIN

Function that assigns an energy value to the streams
```{r}
# Create a function to assign energy values based on slope and wint_width ranges
assign_energy_width <- function(input_df, low_slope_range, medium_slope_range, high_slope_range, low_wint_width_range, medium_wint_width_range, high_wint_width_range) {
  # # Filter for hab_unit == Marsh
  # filtered_df <- input_df %>% filter(hab_unit == "Marsh")
  
  # Create a new column "energy" based on conditions
  filtered_df <- input_df %>%
    mutate(energy = case_when(
      # low slope, low range
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) |
      # medium slope, low width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) |
      # low slope, medium width
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2]) 
      ~ "low",
      # low slope, high width
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # medium slope, medium width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2]) |
      # high slope, low width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2])
       ~ "medium",
      # high slope, high width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # medium slope, high width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # high slope, medium width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2])
       ~ "high",
      TRUE ~ "Unknown"  # Handle any other cases
    ))
  
  return(filtered_df)
}

# Call the function with the provided dataframe and numeric range bounds
low_slope_range <- c(0, 0.0038)
medium_slope_range <- c(0.00381, 0.0214)
high_slope_range <- c(0.0215, 20) #arbitrary large number
low_width_range <- c(0, 3.394)
medium_width_range <- c(3.395, 11.288)
high_width_range <- c(11.289, 300) #arbitrary large number

flow_stl <- assign_energy_width(flow_stl, low_slope_range, medium_slope_range, high_slope_range, low_width_range, medium_width_range, high_width_range)

# unique(flow_stl$energy)
```

## FILTER TO REACHES WHERE WOOD IS A BENEFIT
```{r}
#only keep reaches where there is a benefit of wood to chinook
stilly_bens_filtered<-stilly_bens %>% filter(pop=="fall_chinook" & perc_change>0 & scenario=="Wood")
wood_ben_basin<-unique(stilly_bens_filtered$subbasin_num)
wood_ben_basin<-as.data.frame(wood_ben_basin) %>% rename("subbasin_n"="wood_ben_basin")
wood_ben_basin$subbasin_n<-as.character(wood_ben_basin$subbasin_n)
flow_stl_wood<-left_join(wood_ben_basin, flow_stl, by="subbasin_n")
```

## WRITE A FUNCTION THAT GIVES RELATIVE COST BASED ON ENERGY (materials) AND TRANSPORTATION
##### INTERMEDIATE COST
```{r}
#energy column is called energy (low, medium and high) and transportation is distance_to_nearest_road_mi (values are low, medium and high)

```

## WRITE A FUNCTION THAT GIVES COST RANGES BASED ON PREVIOUS COST FUNCTION AND STREAM FLOW RATE
```{r}

```

## APPLY INFLATION TO COST RANGES
```{r}

```

## APPLY THE COST PER ACRE TO MILES OF STREAM
  # units of the above function are in $/stream mile (Ranges given by per stream mile (assuming 100-400 pieces per stream mile.) All other cells ranges given per structure.
All costs ranges assume purchased material.)
```{r}

```

