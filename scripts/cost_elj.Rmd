---
title: "cost_elj"
author: "Meghan Roberts"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#clearing environment
#rm(list = ls())
#sourcing data
source("../common.R")
```

## LOADING IN THE ROAD DATA/GETTING IT SMALL ENOUGH TO GO ON GITHUB
```{r}
#print(roads)
## no need to run this ever again
# roads <-roads %>% select("OBJECTID", "NAME")
# st_write(roads, here("data/Washington_data/WA_roads_thin.gpkg"))
```

## FIND THE NEAREST ROAD TO EACH STREAM REACH and ASSIGN LMH
# only run once and then just load in the flow_stl_mod
```{r}
# # Create sf objects
# sf_roads <- st_as_sf(roads_stl)
# sf_streamreaches <- st_as_sf(flow_stl, coords = c("lon", "lat"), crs = 4326)
# 
# # Check and match CRS
# if (!identical(st_crs(sf_roads), st_crs(sf_streamreaches))) {
#   sf_roads <- st_transform(sf_roads, st_crs(sf_streamreaches))
# }
# # Find the distance from each stream to the nearest road
# distances <- st_distance(sf_streamreaches, sf_roads)
# 
# # Extract the minimum distance for each stream reach
# min_distances <- apply(distances, 1, min)
# 
# # Add the distances to the original data.frame
# flow_stl$distance_to_nearest_road_m <- min_distances
# flow_stl$distance_to_nearest_road_mi <- flow_stl$distance_to_nearest_road_m *0.000621371
# 
# min(flow_stl$distance_to_nearest_road_mi)
# max(flow_stl$distance_to_nearest_road_mi)
# hist(flow_stl$distance_to_nearest_road_mi)
# 
# # Print the resulting data.frame
# print(flow_stl$distance_to_nearest_road_mi)
# 
# # Check the CRS of sf_streamreaches
# crs_streamreaches <- st_crs(flow_stl)
# print(crs_streamreaches$units)
# 
# # make a column assigning low, medium or high distance depending on the numerical distance to nearest road
# 
# create_transportation_column <- function(distance_column) {
#   transportation_column <- cut(
#     distance_column,
#     breaks = c(-Inf, 7, 20, Inf),
#     labels = c("low", "medium", "high"),
#     include.lowest = TRUE
#   )
#   return(transportation_column)
# }
# 
# # Apply the function to create the 'transportation' column (all are low)
# flow_stl$transportation <- create_transportation_column(flow_stl$distance_to_nearest_road_mi)
# transportation_info<-flow_stl %>% select(c(noaaid, transportation)) %>% st_drop_geometry()
# write.csv(transportation_info, here("data", "HARP", "stl_transportation.csv"), row.names=FALSE)

# #### load in csv file and join to flow_stl
# flow_stl_mod<-full_join(flow_stl, transportation_stl)

```

## STOLEN FROM FLOODPLAIN

Check distribution of slopes and bf_width
```{r}
## Make histogram of slope
hist(flow_stl$slope, main = "Histogram of Slope Column", xlab = "Slope Values")
# Calculate quantiles to split data into three equal sections
quantiles_slope <- quantile(flow_stl$slope, probs = c(1/3, 2/3), na.rm = TRUE)
quantiles_slope
flow_stl$slope_perc<-flow_stl$slope*100
flow_stl$slope_degrees <- atan(flow_stl$slope_perc / 100) * (180 / pi)
hist(flow_stl$slope_degrees, main = "Histogram of Slope Column", xlab = "Slope Values")
## Define values for low, medium and high based on histogram
#maybe 10, 20, 30
## Low <0.0038
## Medium >0.00381 and <0.0214
## High >0.0215
## Make histogram of width
hist(flow_stl$bf_width, main = "Histogram of Width Column", xlab = "Width Values")
quantiles_width <- quantile(flow_stl$bf_width, probs = c(1/3, 2/3), na.rm = TRUE)
quantiles_width
# 20, 40, infin
## Define values for low, medium and high based on histogram
## Low <3.394
## Medium >3.395 and <11.288
## High >11.289
```

## ALSO STOLEN FROM FLOODPLAIN

Function that assigns an energy value to the streams
```{r}
# Create a function to assign energy values based on slope and bf_width ranges
assign_energy_width <- function(input_df, low_slope_range, medium_slope_range, high_slope_range, low_bf_width_range, medium_bf_width_range, high_bf_width_range, slope) {
  # # Filter for hab_unit == Marsh
  # filtered_df <- input_df %>% filter(hab_unit == "Marsh")
  
  # Create a new column "energy" based on conditions
  filtered_df <- input_df %>%
    mutate(energy = case_when(
      # low slope, low range
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       bf_width >= low_bf_width_range[1] & bf_width <= low_bf_width_range[2]) |
      # medium slope, low width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       bf_width >= low_bf_width_range[1] & bf_width <= low_bf_width_range[2]) |
      # low slope, medium width
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       bf_width > low_bf_width_range[2] & bf_width <= medium_bf_width_range[2]) 
      ~ "low",
      # low slope, high width
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       bf_width > medium_bf_width_range[2] & bf_width <= high_bf_width_range[2]) |
      # medium slope, medium width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       bf_width > low_bf_width_range[2] & bf_width <= medium_bf_width_range[2]) |
      # high slope, low width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       bf_width >= low_bf_width_range[1] & bf_width <= low_bf_width_range[2])
       ~ "medium",
      # high slope, high width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       bf_width > medium_bf_width_range[2] & bf_width <= high_bf_width_range[2]) |
      # medium slope, high width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       bf_width > medium_bf_width_range[2] & bf_width <= high_bf_width_range[2]) |
      # high slope, medium width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       bf_width > low_bf_width_range[2] & bf_width <= medium_bf_width_range[2])
       ~ "high",
      TRUE ~ "Unknown"  # Handle any other cases
    ))
  
  return(filtered_df)
}

# Call the function with the provided dataframe and numeric range bounds
low_slope_range <- c(0, 10)
medium_slope_range <- c(10.0000000001, 20)
high_slope_range <- c(20.0000000001, 1000) #arbitrary large number
low_width_range <- c(0, 20)
medium_width_range <- c(20.0000000001, 70)
high_width_range <- c(70.0000000001, 300) #arbitrary large number

flow_stl <- assign_energy_width(flow_stl, low_slope_range, medium_slope_range, high_slope_range, low_width_range, medium_width_range, high_width_range, slope_degrees)

unique(flow_stl$energy)
```

## FILTER TO REACHES WHERE WOOD IS A BENEFIT
```{r}
#only keep reaches where there is a benefit of wood to chinook
stilly_bens_filtered<-stilly_bens %>% filter(pop=="fall_chinook" & perc_change>0 & scenario=="Wood")
wood_ben_basin<-unique(stilly_bens_filtered$subbasin_num)
wood_ben_basin<-as.data.frame(wood_ben_basin) %>% rename("subbasin_n"="wood_ben_basin")
wood_ben_basin$subbasin_n<-as.character(wood_ben_basin$subbasin_n)
flow_stl_wood<-left_join(wood_ben_basin, flow_stl, by="subbasin_n")
```

## WRITE A FUNCTION THAT GIVES RELATIVE COST BASED ON ENERGY (materials) AND TRANSPORTATION
##### INTERMEDIATE COST
```{r}
#energy column is called energy (low, medium and high) and transportation is distance_to_nearest_road_mi (values are low, medium and high)

calculate_intermediate_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      relative_cost = case_when(
        transportation == "low" & energy == "low" |
        transportation == "low" & energy == "medium" ~ "low",
        transportation == "low" & energy == "high" |
        transportation == "medium" & energy == "low" |
        transportation == "medium" & energy == "medium" ~ "medium",
        transportation == "medium" & energy == "high" |
        transportation == "high" & energy == "low" |
        transportation == "high" & energy == "medium" |
        transportation == "high" & energy == "high" ~ "high",
        # Add more conditions for other combinations here
        TRUE ~ "Unknown"  # Default value if no conditions match
      )
    )
  
  return(input_df)
}
  intermediate_cost <- calculate_intermediate_cost(flow_stl_wood)

```

## WRITE A FUNCTION THAT GIVES COST RANGES BASED ON PREVIOUS COST FUNCTION AND STREAM FLOW RATE
```{r}
calculate_final_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      lower_cost_estimate = case_when(
        relative_cost == "low" & energy == "low" ~ 10000,
        relative_cost == "low" & energy == "medium" ~ 20000,
        relative_cost == "low" & energy == "high" ~ 10000,
        relative_cost == "medium" & energy == "low" ~ 20000,
        relative_cost == "medium" & energy == "medium" ~ 15000,
        relative_cost == "medium" & energy == "high" ~ 40000,
        relative_cost == "high" & energy == "low" ~ 20000,
        relative_cost == "high" & energy == "medium" ~ 40000,
        relative_cost == "high" & energy == "high" ~ 60000,
        TRUE ~ 0  # Default value if no conditions match
      ),
      upper_cost_estimate = case_when(
        relative_cost == "low" & energy == "low" ~ 30000,
        relative_cost == "low" & energy == "medium" ~ 50000,
        relative_cost == "low" & energy == "high" ~ 20000,
        relative_cost == "medium" & energy == "low" ~ 50000,
        relative_cost == "medium" & energy == "medium" ~ 45000,
        relative_cost == "medium" & energy == "high" ~ 60000,
        relative_cost == "high" & energy == "low" ~ 40000,
        relative_cost == "high" & energy == "medium" ~ 70000,
        relative_cost == "high" & energy == "high" ~ 80000,
        TRUE ~ 0  # Default value if no conditions match
      )
    )
  
  return(input_df)
}

elj_no_inf_cost <- calculate_final_cost(intermediate_cost)
```

## APPLY PRODUCER PRICE INDICES TO COST RANGES
```{r}
#apply inflation and then par down the dataframe
elj_cost<-elj_no_inf_cost %>% 
  mutate(lower_cost_estimate=lower_cost_estimate*ppi,
           upper_cost_estimate=upper_cost_estimate*ppi) 
```

## CREATE A NEW FUNCTION THAT ADDRESS PROBLEM WITH $/MILE AND $/STRUCTURE
## APPLY THE COST PER ACRE TO MILES OF STREAM
  # units of the above function are in $/stream mile (Ranges given by per stream mile (assuming 100-400 pieces per stream mile.) All other cells ranges given per structure.
All costs ranges assume purchased material.)
50% restored for $/stream mile cases
assume 1 project per 500 meter reach for those that are $/structure

```{r}
elj_cost <- elj_cost %>%
  rowwise() %>%
  mutate(
    final_lower_cost = ifelse((relative_cost == 'low' && energy == 'low') || (relative_cost == 'medium' && energy == 'low') || (relative_cost == 'low' && energy == 'medium'),
                                  lower_cost_estimate * length * 0.000621371 *0.5,
                                  lower_cost_estimate*1),
    final_upper_cost = ifelse((relative_cost == 'low' && energy == 'low') || (relative_cost == 'medium' && energy == 'low') || (relative_cost == 'low' && energy == 'medium'),
                                  upper_cost_estimate * length * 0.000621371 *0.5,
                                  upper_cost_estimate*1)
  )

elj_cost$avg_cost<-(elj_cost$final_lower_cost+elj_cost$final_upper_cost)/2
```


```{r}
# #checking if any streams fall into the category that I would need to consider $/structure
# unique(elj_cost[c("relative_cost", "energy")])
# #convert reach length from meters to miles
# elj_cost$length_mi<-elj_cost$length*0.000621371
# #multiply miles by $/mile to get total dollars
# #also only apply ELJ costs to 50% of the stream mileage
# elj_cost$final_lower_cost<-elj_cost$lower_cost_estimate*elj_cost$length_mi*0.5
# elj_cost$final_upper_cost<-elj_cost$upper_cost_estimate*elj_cost$length_mi*0.5
# elj_cost$avg_cost<-(elj_cost$final_lower_cost+elj_cost$final_upper_cost)/2
```

## FIND THE COST PER SUBBASIN
```{r}
#filtering the benefits
elj_bens<-stilly_bens %>% filter(scenario=="Wood" & pop=="fall_chinook")
#calculating final cost riparian planting by subbasin 
elj_cost_subbasin <- elj_cost %>%
  #dropping stream geometries
  st_drop_geometry() %>% 
  #grouping by subbasin
  group_by(noaa_subba) %>% 
  #adding up all lower cost ranges for reach costs by subbasin 
  summarize(lower_subba_cost = sum(final_lower_cost),
            upper_subba_cost = sum(final_upper_cost),
            avg_subba_cost = (lower_subba_cost + upper_subba_cost)/2) %>% 
  #joining with subs_stl to get the geometries of the subbasins
  right_join(subs_stl[,1] ) %>% 
  #add subbasin salmon ppltn projected and current %>% 
  left_join(elj_bens %>% 
              select(subbasin, n, n_curr), by = c("noaa_subba" = "subbasin")) %>% 
  # finding increased increased fish from intervention
  mutate(n_diff = n - n_curr,
         #creating a cost benefit ratio by dividing avg cost by # new fish
         n_ratio = avg_subba_cost/n_diff) %>% 
  #reassigning it as sf b/c geometries became empty after le
  st_as_sf()

write.csv(elj_cost_subbasin , here("data", "final_dfs", "elj_costs.csv"))
```


## MAP THE RESULTS
```{r}
#convert to sf for mapping purposes
elj_cost_sf <- st_as_sf(elj_cost)%>% 
  select(noaaid,final_lower_cost, final_upper_cost, avg_cost, noaa_subba)
ggplot() +
  geom_sf(data = subs_stl, aes()) +
  geom_sf(data = elj_cost_sf, aes(color = avg_cost)) + #use color, not fill bc line
  scale_color_viridis_c(breaks = c(0, 2000, 4000, 6000), option = "E", name = "Average Cost ($)", direction=-1)+
  theme_minimal()
```


## Figure showing cost per subbasin graphically
```{r}
#creating a column with pretty subbasin names
elj_cost_sf$subbasin_name <- str_replace_all(elj_cost_sf$noaa_subba, "_", " ") 
elj_cost_sf$subbasin_name <-str_replace_all(elj_cost_sf$subbasin_name, "Stillaguamish", "")
elj_cost_sf$subbasin_name <-str_replace_all(elj_cost_sf$subbasin_name, "mainstem", "Mainstem")

#create a summary table that has the lower, upper and average cost by subbasin
elj_summary<-elj_cost_sf %>% group_by(subbasin_name) %>% 
  summarise(
    sum_final_lower_cost = sum(final_lower_cost, na.rm = TRUE),
    sum_final_upper_cost = sum(final_upper_cost, na.rm = TRUE),
    sum_avg_cost = sum(avg_cost, na.rm = TRUE)
  )

#figure itself
ggplot(elj_summary, aes(x = subbasin_name)) +
  geom_errorbar(
    aes(ymin = sum_final_lower_cost/1000000, ymax = sum_final_upper_cost/1000000),
    position = "dodge",
    width = 0.2
  ) +
  geom_point(aes(y = sum_avg_cost/1000000), position = "dodge", size = 3) +
  labs(title = "Costs per Subbasin in the Stillaguamish",
       x = "Subbasin",
       y = "Cost (Millions of Dollars)") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

<!-- #incorporate benefits into df (from benefit_data) -->
<!-- ```{r} -->

<!-- elj_cost_ben <- full_join(elj_cost_sf, elj_bens, by = c("noaa_subba" = "subbasin")) -->
<!-- #calculate cost benefit ratio -->
<!-- elj_cost_ben$n_diff<-elj_cost_ben$n-elj_cost_ben$n_curr -->
<!-- elj_cost_ben$ratio_n<-elj_cost_ben$avg_cost/(elj_cost_ben$n_diff) -->
<!-- elj_cost_ben <- elj_cost_ben %>% -->
<!--   mutate(ratio_n_log = if_else(!is.na(ratio_n) & ratio_n != 0, log(ratio_n),NA_real_)) -->
<!-- write.csv(elj_cost_ben, here("data", "final_dfs", "elj_costs.csv")) -->
<!-- ``` -->

