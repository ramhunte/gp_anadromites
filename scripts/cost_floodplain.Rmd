---
title: "cost_floodplain"
author: "Meghan Roberts"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, include=FALSE, message = FALSE, error = FALSE)


#clearing environment
rm(list = ls())

#sourcing data
source("../common.R")
source("functions.R")
```

Reminders *Remember to change the width value (as needed) and fix the matching between noaa_subba and reach_names.* Also change the low, medium and high division associated with the multipliers


##### IMPORTANT NOTES #######


* I think that a lot of the streams we mapped from the flow_stl dont need to be included b/c they dont have Chinook in them. A lot of the upper streams only have steelhead and coho (check shiny app https://acg-noaa.shinyapps.io/harpviewer/ under "streams map" and then select only chinook). Maybe need to filter flow_stl to just chinook? Otherwise we are restoring areas that dont have Chinook in them 

* Maybe we need to filter habitat back to just historic? it looks like we have prices and benefits for subbasins that Tim doesnt 






## Filtering floodplain data

```{r}
#taking just the geometries and names of subbasins
#changing crs to match floodplain habitat crs
subs_mod <- subs_stl %>% 
  select(noaa_subba) %>% 
  st_transform(26910)

# flood_stl_hist <- flood_stl %>% 
  # filter(period == "Hist")


## finding the sub basins that each fp habitat lies in. If it lies in multiple sub basins, it was split up into multiple polygons by the sub basin (performed by st_intersection)
hist_flood_stl <- st_intersection(subs_mod, filter(flood_stl, period %in% "Hist")) 
  # filter(period=="Hist")

## filtering for specific columns to make the join cleaner
slope_width_stl<-flow_stl %>% 
  select(noaaid, slope, bf_width, pond_overl, chinook, habitat) %>% 
  st_drop_geometry()

#change width as needed
## Join the floodplain habitats with the associated stream variables
hist_flood_stl_var<- left_join(hist_flood_stl, slope_width_stl, by = "noaaid")

#need to fix because not all reach names have noaa_subba matches
## Join the variables with the side channel multipliers
hist_flood_stl_var_mult<-left_join(hist_flood_stl_var, side_channel_mult_stl, by = c("noaa_subba"= "reach_name"))%>% 
  mutate(project_number = 1:n()) %>% 
  #some of the reaches dont have side channel multipliers b/c no significant fp habitat, so we are giving them a vlaue of 1.001 so NA values are not present 
  mutate(multiplier = ifelse(is.na(multiplier), 0.001, multiplier))

## Histogram of Multiplier Values
hist(hist_flood_stl_var_mult$multiplier, main = "Histogram of Multiplier Column", xlab = "Multiplier Values", breaks=20)

## Define values for low, medium and high based on histogram
## Low <0.4
## Medium >0.4 and <1
## High >1
```

Both ponds have a side channel multiplier of 0 Assumed substantial material cost for upper and lower cost estimates Assumes inflation rate of 2.61% per year between 2003 and today, producing a cumulative price increase of 67.28%
(PPI used: https://fred.stlouisfed.org/series/WPUSI012011)
2003-03-01: 145.200
2023-11-01: 327.242
percent change

NEW ONE

```{r}

# Create a function to calculate cost estimates with inflation adjustment
calculate_pond_cost_inflation_geometry_custom <- function(input_df, low_bound, medium_bound, high_bound) {
  # Filter for hab_unit == Pond or Lake
  filtered_df <- input_df %>% filter(hab_unit %in% c("Pond", "Lake"))
  
  # Create a new dataframe
  pond_cost_stl <- data.frame(
    project_number = filtered_df$project_number,
    upper_cost = ifelse(filtered_df$multiplier < medium_bound, 40000, 
                        ifelse(filtered_df$multiplier <= high_bound, 60000, 80000)) * ppi,
    lower_cost = ifelse(filtered_df$multiplier < medium_bound, 30000, 
                        ifelse(filtered_df$multiplier <= high_bound, 40000, 60000)) * ppi
  )
  
  # Add the geometry and area column to the new dataframe
  pond_cost_stl$geometry <- filtered_df$geometry
  pond_cost_stl$area_ha <- filtered_df$area_ha
  pond_cost_stl$noaa_subba <- filtered_df$noaa_subba
  pond_cost_stl$hab_unit <- filtered_df$hab_unit
  
  return(pond_cost_stl)
}

# Define the bounds for low, medium, and high multipliers
low_multiplier_bound <- 0
medium_multiplier_bound <- 0.5
high_multiplier_bound <- 1.5

# Call the function with the provided dataframe and custom bounds
pond_cost_stl_inflated_custom <- calculate_pond_cost_inflation_geometry_custom(
  hist_flood_stl_var_mult, low_multiplier_bound, medium_multiplier_bound, high_multiplier_bound)

pond_cost_inflation <- pond_cost_stl_inflated_custom %>% 
  mutate(area_a=area_ha*2.47105) %>% 
  mutate(total_lower_cost=lower_cost*area_a) %>% 
  mutate(total_upper_cost=upper_cost*area_a)
```

Create a function that takes different multiplier values and energies and creates a upper and lower cost range

Currently using zero as a placeholder for when side channel multiplier values don't exist

```{r}
#new way of calculating earth moving with multiplier and stream size
hist_flood_stl_var_mult <- hist_flood_stl_var_mult %>% 
  mutate(earth_moving = case_when(
    habitat == "SmStream" & multiplier < medium_multiplier_bound ~ "low",
    habitat == "SmStream" & multiplier <= high_multiplier_bound ~ "medium",
    habitat == "SmStream" & multiplier > high_multiplier_bound ~ "high",
    habitat == "LgStream" & multiplier < medium_multiplier_bound ~ "medium",
    habitat == "LgStream" & multiplier <= high_multiplier_bound ~ "high",
    habitat == "LgStream" & multiplier > high_multiplier_bound ~ "high",
    TRUE ~ "unknown"  # You can add a default case if needed
  ))


calculate_marsh_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      lower_cost = case_when(
        earth_moving == "low" & energy == "low" ~ 20000,
        earth_moving == "low" & energy == "medium" ~ 40000,
        earth_moving == "low" & energy == "high" ~ 60000,
        earth_moving == "medium" & energy == "low" ~ 40000,
        earth_moving == "medium" & energy == "medium" ~ 70000,
        earth_moving == "medium" & energy == "high" ~ 100000,
        earth_moving == "high" & energy == "low" ~ 60000,
        earth_moving == "high" & energy == "medium" ~ 130000,
        earth_moving == "high" & energy == "high" ~ 200000,
        # Add more conditions for other combinations here
        TRUE ~ 0  # Default value if no conditions match
      ),
      upper_cost = case_when(
        earth_moving == "low" & energy == "low" ~ 40000,
        earth_moving == "low" & energy == "medium" ~ 70000,
        earth_moving == "low" & energy == "high" ~ 90000,
        earth_moving == "medium" & energy == "low" ~ 60000,
        earth_moving == "medium" & energy == "medium" ~ 100000,
        earth_moving == "medium" & energy == "high" ~ 200000,
        earth_moving == "high" & energy == "low" ~ 100000,
        earth_moving == "high" & energy == "medium" ~ 200000,
        earth_moving == "high" & energy == "high" ~ 300000,
        # Add more conditions for other combinations here
        TRUE ~ 0  # Default value if no conditions match
      )
    )
  
  return(input_df)
}


```


```{r}
#determining area of side channel habitat
#making all positive percent change equal to NA bc no restoration needed
side_channel_length$perc_change[side_channel_length$perc_change>0]<-NA

#join hist_flood . .  with side channel length
side_channel_flow<-flow_stl %>% left_join(side_channel_length, by="noaa_subba") %>% 
  #assume side channels are 1/3 of the width of the river
  mutate(sc_area=length*bf_width*0.3*(abs(perc_change)/100)) %>% 
  #join with multiplier
  full_join(side_channel_mult_stl, by=c("noaa_subba"="reach_name"))
#replace 0 with NA for side channel multipliers
side_channel_flow$multiplier[side_channel_flow$multiplier==NA]<-0

side_channel_flow<-assign_energy_width(side_channel_flow)

side_channel_flow <- side_channel_flow %>% 
  mutate(earth_moving = case_when(
    habitat == "SmStream" & multiplier < medium_multiplier_bound ~ "low",
    habitat == "SmStream" & multiplier <= high_multiplier_bound ~ "medium",
    habitat == "SmStream" & multiplier > high_multiplier_bound ~ "high",
    habitat == "LgStream" & multiplier < medium_multiplier_bound ~ "medium",
    habitat == "LgStream" & multiplier <= high_multiplier_bound ~ "high",
    habitat == "LgStream" & multiplier > high_multiplier_bound ~ "high",
    TRUE ~ "unknown"  # You can add a default case if needed
  ))

side_channel_flow<-calculate_marsh_cost(side_channel_flow)

## account for inflation and get area in acres to get total cost
side_channel_flow <- side_channel_flow %>% 
  mutate(lower_cost=lower_cost* ppi) %>% 
  mutate(upper_cost=upper_cost* ppi) %>% 
  mutate(area_a=sc_area*0.000247105) %>% #meters squared to hectares
  mutate(total_lower_cost=lower_cost*area_a) %>% 
  mutate(total_upper_cost=upper_cost*area_a) 

##get geometry of subbasin
#calculating final cost riparian planting by subbasin 
side_channel_flow <- side_channel_flow %>%
  #dropping stream geometries
  st_drop_geometry() %>% 
  #grouping by subbasin
  group_by(noaa_subba) %>% 
  #adding up all lower cost ranges for reach costs by subbasin and multiplying by the producer price index 
  summarize(total_lower_cost = sum(lower_cost),
            total_upper_cost = sum(upper_cost)) %>% 
  #joining with subs_stl to get the geometries of the subbasins
  right_join(subs_stl[,1] )%>% 
  mutate(hab_unit="side_channel") %>% 
  st_as_sf()
```


```{r}
hist_flood_stl_var_mult$slope_gradient <- hist_flood_stl_var_mult$slope*100
marsh_energy_stl<-assign_energy_width(hist_flood_stl_var_mult)

marsh_cost <- calculate_marsh_cost(marsh_energy_stl)

# #checking if any subbasins with assigned multipliers had habitat
# result<-marsh_cost %>% filter(multiplier==0.001)

## account for inflation and get area in acres to get total cost
marsh_cost_inflation <- marsh_cost %>% 
  mutate(lower_cost=lower_cost* ppi) %>% 
  mutate(upper_cost=upper_cost* ppi) %>% 
  mutate(area_a=area_ha*2.47105) %>% 
  mutate(total_lower_cost=lower_cost*area_a) %>% 
  mutate(total_upper_cost=upper_cost*area_a)
```

#combining the marsh costs and the pond costs
```{r}
#marsh costs
marsh_cost_inflation_select<-marsh_cost_inflation %>% 
  select(geometry, noaa_subba, hab_unit, total_lower_cost, total_upper_cost) 

#pond costs
pond_cost_inflation_select<-pond_cost_inflation %>% 
  select(geometry, noaa_subba, hab_unit, total_lower_cost, total_upper_cost)

#side channel costs
side_channel_inflation_select<-side_channel_flow %>% 
  select(noaa_subba,total_lower_cost, total_upper_cost) %>% 
  st_drop_geometry()

#total cost
stilly_total_cost<-full_join(marsh_cost_inflation_select, pond_cost_inflation_select)

# %>% full_join(stilly_total_cost, side_channel_inflation_select) 

#grouped total costs (pond and marsh only)
stilly_subbasin_cost <- stilly_total_cost %>% 
  group_by(noaa_subba) %>% 
  summarise(total_lower_cost = sum(total_lower_cost), total_upper_cost = sum(total_upper_cost)) %>%
  st_drop_geometry()

#adding side channel
stilly_subbasin_cost<-full_join(stilly_subbasin_cost, side_channel_inflation_select) %>% st_drop_geometry() %>% group_by(noaa_subba) %>% summarize(total_lower_cost=sum(total_lower_cost), 
    total_upper_cost=sum(total_upper_cost))%>% 
  mutate(average_cost=(total_upper_cost+total_lower_cost)/2)

#need to join the subbasin geometries 
 
 stilly_subbasin_cost <- left_join(subs_stl, stilly_subbasin_cost, by = "noaa_subba") %>% 
   select(noaa_subba, total_lower_cost, total_upper_cost, geometry) 
```



## incorporating benefits
```{r}
#include only subbasins that have a benefit to chinook, but retain rows for other pops
stilly_bens_flood_subba <- stilly_bens %>% filter(scenario=="Floodplain" &pop == "fall_chinook" & perc_change > 0) %>% select(subbasin) %>% unique()
#join this to stilly_bens and filter for wood sceario
stilly_bens_flood<-left_join(stilly_bens_flood_subba, stilly_bens) %>% filter(scenario=="Floodplain") %>% drop_na()


flood_cost_ben <- full_join(stilly_subbasin_cost, stilly_bens_flood, by = c("noaa_subba" = "subbasin"))

flood_cost_ben<-flood_cost_ben %>%  
  mutate(n_diff = n - n_curr,
         total_avg_cost= (total_lower_cost+total_upper_cost)/2,
         #creating an annual cost benefit ratio 
         cb_ratio = ann_cost_ben(C = total_avg_cost, f = n_diff)
  ) 


# ##need to manipulate values so that when n_diff=0 (zero fish are benefitted) the ratio is 0, also I need the value to be NA when avg_cost is NA
# ##logically the value should never be NA (that means we didn't calculate a price for a basin with benefits)
# flood_cost_ben <- flood_cost_ben %>%
#   mutate(ratio_n = ifelse(!is.na(avg_cost), avg_cost / pmax(1, n-n_curr), NA))
# 
# # flood_cost_ben <- flood_cost_ben %>%
# #   mutate(ratio_n = NA) %>% 
# #   mutate(ratio_n = ifelse(!is.na(avg_cost), avg_cost / n-n_curr, NA))
# flood_cost_ben$ratio_n <- replace(flood_cost_ben$ratio_n, is.infinite(flood_cost_ben$ratio_n), 0)
# # flood_cost_ben <- flood_cost_ben %>%
# #   mutate(ratio_n_log = if_else(!is.na(ratio_n) & ratio_n != 0, log(ratio_n), NA_real_))


bens_filter_fp <- flood_cost_ben %>% 
  filter(pop == "fall_chinook" & n_diff >= 1)

flood_cost_ben <- flood_cost_ben %>% 
  filter(noaa_subba %in% bens_filter_fp$noaa_subba)




st_write(flood_cost_ben, here("data", "final_dfs", "fp_costs.gpkg"), append=FALSE)
```

#Creating a df with area by marsh, pond and side channel
```{r}
marsh_pond_area<-full_join(marsh_cost_inflation, pond_cost_inflation)
side_channel_flow$area_ha<-st_area(side_channel_flow$geometry) / 10000  # Convert square meters to hectares
side_channel_flow<-side_channel_flow %>% st_drop_geometry() %>% units::drop_units()

fp_area_subbasin<-full_join(marsh_pond_area, side_channel_flow) %>% group_by(noaa_subba, hab_unit) %>%
  summarise(total_area_ha = sum(area_ha)) %>% st_drop_geometry()

# write.csv(fp_area_subbasin, here("data", "final_dfs", "fp_area_subbasin.csv"))

#summary by restoration_type
fp_area_sum<-full_join(marsh_pond_area, side_channel_flow) %>% 
  group_by(hab_unit) %>% summarise(area_ha=sum(area_ha)) %>%  st_drop_geometry()

```




