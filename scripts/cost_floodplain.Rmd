---
title: "cost_floodplain"
author: "Meghan Roberts"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, include=FALSE, message = FALSE, error = FALSE)


#clearing environment
# rm(list = ls())

#sourcing data
source("../common.R")
```

Reminders *Remember to change the width value (as needed) and fix the matching between noaa_subba and reach_names.* Also change the low, medium and high division associated with the multipliers

## Filtering floodplain data

```{r}
#taking just the geometries and names of subbasins
#changing crs to match floodplain habitat crs
subs_mod <- subs_stl %>% 
  select(noaa_subba) %>% 
  st_transform(26910)

## fiding the sub basins that each fp habitat lies in. If it lies in multiple sub basins, it was split up into multiple polygons by the sub basin (performed by st_intersection)
hist_flood_stl <- st_intersection(subs_mod, flood_stl) 
  # filter(period=="Hist")

## filtering for specific columns to make the join cleaner
slope_width_stl<-flow_stl %>% 
  select(noaaid, slope, wint_width, pond_overl, chinook, habitat) %>% 
  st_drop_geometry()

#change width as needed
## Join the floodplain habitats with the associated stream variables
hist_flood_stl_var<- left_join(hist_flood_stl, slope_width_stl, by = "noaaid")

#need to fix because not all reach names have noaa_subba matches
## Join the variables with the side channel multipliers
hist_flood_stl_var_mult<-left_join(hist_flood_stl_var, side_channel_mult_stl, by = c("noaa_subba"= "reach_name"))%>% 
  mutate(project_number = 1:n()) %>% 
  #some of the reaches dont have side channel multipliers b/c no significant fp habitat, so we are giving them a vlaue of 1.001 so NA values are not present 
  mutate(multiplier = ifelse(is.na(multiplier), 1.001, multiplier))

## Subtract one from multiplier column and do absolute value
hist_flood_stl_var_mult$multiplier<-abs(hist_flood_stl_var_mult$multiplier-1)

## Histogram of Multiplier Values
hist(hist_flood_stl_var_mult$multiplier, main = "Histogram of Multiplier Column", xlab = "Multiplier Values")

## Define values for low, medium and high based on histogram
## Low <0.4
## Medium >0.4 and <1
## High >1
```

Both ponds have a side channel multiplier of 0 Assumed substantial material cost for upper and lower cost estimates Assumes inflation rate of 2.61% per year between 2003 and today, producing a cumulative price increase of 67.28%
(PPI used: https://fred.stlouisfed.org/series/WPUSI012011)
2003-03-01: 145.200
2023-11-01: 327.242
percent change

NEW ONE

```{r}

# Create a function to calculate cost estimates with inflation adjustment
calculate_pond_cost_inflation_geometry_custom <- function(input_df, low_bound, medium_bound, high_bound) {
  # Filter for hab_unit == Pond or Lake
  filtered_df <- input_df %>% filter(hab_unit %in% c("Pond", "Lake"))
  
  # Create a new dataframe
  pond_cost_stl <- data.frame(
    project_number = filtered_df$project_number,
    upper_cost = ifelse(filtered_df$multiplier < medium_bound, 40000, 
                        ifelse(filtered_df$multiplier <= high_bound, 60000, 80000)) * ppi,
    lower_cost = ifelse(filtered_df$multiplier < medium_bound, 30000, 
                        ifelse(filtered_df$multiplier <= high_bound, 40000, 60000)) * ppi
  )
  
  # Add the geometry and area column to the new dataframe
  pond_cost_stl$geometry <- filtered_df$geometry
  pond_cost_stl$area_ha <- filtered_df$area_ha
  pond_cost_stl$noaa_subba <- filtered_df$noaa_subba
  pond_cost_stl$hab_unit <- filtered_df$hab_unit
  
  return(pond_cost_stl)
}

# Define the bounds for low, medium, and high multipliers
low_multiplier_bound <- 0
medium_multiplier_bound <- 0.4
high_multiplier_bound <- 1

# Call the function with the provided dataframe and custom bounds
pond_cost_stl_inflated_custom <- calculate_pond_cost_inflation_geometry_custom(
  hist_flood_stl_var_mult, low_multiplier_bound, medium_multiplier_bound, high_multiplier_bound)

pond_cost_inflation <- pond_cost_stl_inflated_custom %>% 
  mutate(area_a=area_ha*2.47105) %>% 
  mutate(total_lower_cost=lower_cost*area_a) %>% 
  mutate(total_upper_cost=upper_cost*area_a)
```

Check distribution of slopes and wint_width

```{r}
## Make histogram of slope
hist(hist_flood_stl_var_mult$slope, main = "Histogram of Slope Column", xlab = "Slope Values")
## Define values for low, medium and high based on histogram
## Low <0.005
## Medium >0.005 and <0.015
## High >0.015
## Make histogram of width
hist(hist_flood_stl_var_mult$wint_width, main = "Histogram of Width Column", xlab = "Width Values")
## Define values for low, medium and high based on histogram
## Low <20
## Medium >20 and <70
## High >70
```

Create a function that takes different multiplier values and energies and creates a upper and lower cost range

Currently using zero as a placeholder for when side channel multiplier values don't exist

```{r}
# #old method of calculating earth moving with just multiplier
# hist_flood_stl_var_mult<-hist_flood_stl_var_mult %>%
#   mutate(earth_moving_old=ifelse(multiplier < medium_multiplier_bound, "low",
#                         ifelse(multiplier <= high_multiplier_bound, "medium", "high")))

#new way of calculating earth moving with multiplier and stream size
hist_flood_stl_var_mult <- hist_flood_stl_var_mult %>% 
  mutate(earth_moving = case_when(
    habitat == "SmStream" & multiplier < medium_multiplier_bound ~ "low",
    habitat == "SmStream" & multiplier <= high_multiplier_bound ~ "medium",
    habitat == "SmStream" & multiplier > high_multiplier_bound ~ "high",
    habitat == "LgStream" & multiplier < medium_multiplier_bound ~ "medium",
    habitat == "LgStream" & multiplier <= high_multiplier_bound ~ "high",
    habitat == "LgStream" & multiplier > high_multiplier_bound ~ "high",
    TRUE ~ "unknown"  # You can add a default case if needed
  ))


calculate_marsh_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      lower_cost = case_when(
        earth_moving == "low" & energy == "low" ~ 20000,
        earth_moving == "low" & energy == "medium" ~ 40000,
        earth_moving == "low" & energy == "high" ~ 60000,
        earth_moving == "medium" & energy == "low" ~ 40000,
        earth_moving == "medium" & energy == "medium" ~ 70000,
        earth_moving == "medium" & energy == "high" ~ 100000,
        earth_moving == "high" & energy == "low" ~ 60000,
        earth_moving == "high" & energy == "medium" ~ 130000,
        earth_moving == "high" & energy == "high" ~ 200000,
        # Add more conditions for other combinations here
        TRUE ~ 0  # Default value if no conditions match
      ),
      upper_cost = case_when(
        earth_moving == "low" & energy == "low" ~ 40000,
        earth_moving == "low" & energy == "medium" ~ 70000,
        earth_moving == "low" & energy == "high" ~ 90000,
        earth_moving == "medium" & energy == "low" ~ 60000,
        earth_moving == "medium" & energy == "medium" ~ 100000,
        earth_moving == "medium" & energy == "high" ~ 200000,
        earth_moving == "high" & energy == "low" ~ 100000,
        earth_moving == "high" & energy == "medium" ~ 200000,
        earth_moving == "high" & energy == "high" ~ 300000,
        # Add more conditions for other combinations here
        TRUE ~ 0  # Default value if no conditions match
      )
    )
  
  return(input_df)
}


```

Need to define which energy levels are associated with each slope/width combo ---\> did this in the google doc

THIS FUNCTION DEFINES ENERGY BASED ON SLOPE AND WINT_WIDTH

```{r}
# Create a function to assign energy values based on slope and wint_width ranges
assign_energy_width <- function(input_df, low_slope_range, medium_slope_range, high_slope_range, low_wint_width_range, medium_wint_width_range, high_wint_width_range) {
  # Filter for hab_unit == Marsh
  filtered_df <- input_df %>% filter(hab_unit == "Marsh")
  # Create a new column "energy" based on conditions
  filtered_df <- filtered_df %>%
    mutate(energy = case_when(
      # low slope, low range
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) |
      # medium slope, low width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) |
      # low slope, medium width
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2]) 
      ~ "low",
      # low slope, high width
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # medium slope, medium width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2]) |
      # high slope, low width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2])
       ~ "medium",
      # high slope, high width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # medium slope, high width
      (slope > low_slope_range[2] & slope <= medium_slope_range[2] & 
       wint_width > medium_wint_width_range[2] & wint_width <= high_wint_width_range[2]) |
      # high slope, medium width
      (slope > medium_slope_range[2] & slope <= high_slope_range[2] & 
       wint_width > low_wint_width_range[2] & wint_width <= medium_wint_width_range[2])
       ~ "high",
      TRUE ~ "Unknown"  # Handle any other cases
    ))
  return(filtered_df)
}

# Call the function with the provided dataframe and numeric range bounds
low_slope_range <- c(0, 0.005)
medium_slope_range <- c(0.0051, 0.015)
high_slope_range <- c(0.0151, 20) #arbitrary large number
low_width_range <- c(0, 19)
medium_width_range <- c(20, 69)
high_width_range <- c(70, 300) #arbitrary large number

marsh_energy_stl <- assign_energy_width(hist_flood_stl_var_mult, low_slope_range, medium_slope_range, high_slope_range, low_width_range, medium_width_range, high_width_range)

marsh_cost <- calculate_marsh_cost(marsh_energy_stl)

## account for inflation and get area in acres to get total cost
marsh_cost_inflation <- marsh_cost %>% 
  mutate(lower_cost=lower_cost* 1.6728) %>% 
  mutate(upper_cost=upper_cost* 1.6728) %>% 
  mutate(area_a=area_ha*2.47105) %>% 
  mutate(total_lower_cost=lower_cost*area_a) %>% 
  mutate(total_upper_cost=upper_cost*area_a)
```

```{r}
#marsh costs
marsh_cost_inflation_select<-marsh_cost_inflation %>% 
  select(geometry, project_number, noaa_subba, hab_unit,total_lower_cost, total_upper_cost)

#pond costs
pond_cost_inflation_select<-pond_cost_inflation %>% 
  select(geometry, project_number, noaa_subba, hab_unit, total_lower_cost, total_upper_cost)

#total costs 
stilly_total_cost<-full_join(marsh_cost_inflation_select, pond_cost_inflation_select) %>% 
  mutate(average_cost=(total_upper_cost+total_lower_cost)/2)

#grouped total costs 


stilly_subbasin_cost <- stilly_total_cost %>% 
  group_by(noaa_subba) %>% 
  summarise(total_lower_cost = sum(total_lower_cost), total_upper_cost = sum(total_upper_cost)) %>%
  st_drop_geometry()


#need to join the subbasin geometries 
 
 stilly_subbasin_cost <- left_join(subs_stl, stilly_subbasin_cost, by = "noaa_subba") %>% 
   select(noaa_subba, total_lower_cost, total_upper_cost, geometry) %>% 
   mutate(avg_cost = (total_lower_cost + total_upper_cost)/2)
  
#final lower and upper cost estimates
 final_cost_range <- c(sum(stilly_subbasin_cost$total_lower_cost, na.rm = T), sum(stilly_subbasin_cost$total_upper_cost, na.rm = T))
 

```

##MAP
```{r}
 ggplot() +
  geom_sf(data = subs_stl, aes()) +
  geom_sf(data = stilly_subbasin_cost, aes(fill = avg_cost)) +
  scale_fill_viridis_b(breaks = c(5000000, 20000000, 100000000),
                       labels = c("5 Million", "20 Million", "100 Million"), option = "E", 
                       direction=-1) +
  # scale_fill_stepsn(breaks = c(5000000, 20000000, 100000000), colors = c("green", "orange", "blue", "yellow")) +
  
  geom_sf(data = flow_stl, color = "blue", alpha = .3) +
  # scale_fill_continuous() +
  theme_minimal()+
  labs(fill="Average Cost ($)")
```

##Figure showing cost per subbasin graphically
```{r}
#creating a column with pretty subbasin names
stilly_subbasin_cost$subbasin_name <- str_replace_all(stilly_subbasin_cost$noaa_subba, "_", " ") 
stilly_subbasin_cost$subbasin_name <-str_replace_all(stilly_subbasin_cost$subbasin_name, "Stillaguamish", "")
stilly_subbasin_cost$subbasin_name <-str_replace_all(stilly_subbasin_cost$subbasin_name, "mainstem", "Mainstem")
#figure itself
ggplot(stilly_subbasin_cost, aes(x = subbasin_name)) +
  geom_errorbar(
    aes(ymin = total_lower_cost/1000000, ymax = total_upper_cost/1000000),
    position = "dodge",
    width = 0.2
  ) +
  geom_point(aes(y = avg_cost/1000000), position = "dodge", size = 3) +
  labs(title = "Costs per Subbasin in the Stillaguamish",
       x = "Subbasin",
       y = "Cost (Millions of Dollars)") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```


```{r}
test <- ggplot() +
  geom_sf(data = subs_stl) +
  geom_sf(data = stilly_total_cost, aes(fill = noaa_subba)) +
  theme_minimal() 
test

test + theme(legend.position = "none")
  
```






