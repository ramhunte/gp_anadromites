---
title: "cost_floodplain"
author: "Meghan Roberts"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(sf)
library(ggspatial)
library(tmap)
library(here)
library(janitor)
library(ggplot2)
```
# attemtp to make a source 
```{r}
# source("common.R")
```



```{r}
flow_stl <- st_read(here("data", "Flowline_STL", "Flowline_STL_20220928.shp")) %>% 
  clean_names()
flood_stl <- st_read(here("data", "Floodplain_STL", "Floodplain_STL_20220928.shp")) %>% 
  clean_names()
subs_stl <- st_read(here("data", "Subbasins_STL", "Subbasins_STL_20220928.shp")) %>% 
  clean_names()
```


```{r}
#read in flow data 
flow_df <- fortify(flow_stl)




```

```{r}
#compress into x and y (plotting hates z)
flow_sf <- st_zm(flow_stl, what = "ZM")
flood_sf <- st_zm(flood_stl, what = "ZM")
subs_sf <- st_zm(subs_stl, what = "ZM")
```

Remember to change the width value (as needed) and fix the matching between noaa_subba and reach_names.
Also change the low, medium and high division asscoiated with the multipliers
```{r}
## filtering for only floodplains that existed historically, but not currently
hist_flood_stl<-flood_sf %>% 
  filter(period=="Hist")
## filtering for specific columns to make the join cleaner
slope_width_stl<-flow_sf %>% 
  select(noaaid, slope, wint_width, pond_overl, chinook, noaa_subba) %>% 
  st_drop_geometry()
#change width as needed
## Join the floodplain habitats with the associated stream variables
hist_flood_stl_var<- left_join(hist_flood_stl, slope_width_stl, by = "noaaid")
## read in side channel multiplier info
side_channel_mult_stl<-read_csv(here("data", "HARP_Side_Channel_Mult_STL.csv"))
#need to fix because not all reach names have noaa_subba matches
## Join the variables with the side channel multipliers
hist_flood_stl_var_mult<-left_join(hist_flood_stl_var, side_channel_mult_stl, by = c("noaa_subba"= "reach_name"))%>% 
  mutate(project_number = 1:n())
## Subtract one from multiplier column and do absolute value
hist_flood_stl_var_mult$multiplier<-abs(hist_flood_stl_var_mult$multiplier-1)
## Histogram of Multiplier Values
hist(hist_flood_stl_var_mult$multiplier, main = "Histogram of Multiplier Column", xlab = "Multiplier Values")
## Define values for low, medium and high based on histogram
## Low <0.4
## Medium >0.4 and <1
## High >1
```

Both ponds have a side channel multiplier of 0
Assumed substantial material cost for upper and lower cost estimates
Assumes inflation rate of 2.61% per year between 2003 and today, producing a cumulative price increase of 67.28% (https://www.officialdata.org/us/inflation/2003?amount=30000)

NEW ONE
```{r}
# Create a function to calculate cost estimates with inflation adjustment
calculate_pond_cost_inflation_geometry_custom <- function(input_df, low_bound, medium_bound, high_bound) {
  # Filter for hab_unit == Pond or Lake
  filtered_df <- input_df %>% filter(hab_unit %in% c("Pond", "Lake"))
  
  # Create a new dataframe
  pond_cost_stl <- data.frame(
    project_number = filtered_df$project_number,
    upper_cost = ifelse(filtered_df$multiplier < medium_bound, 40000, 
                        ifelse(filtered_df$multiplier <= high_bound, 60000, 80000)) * 1.6728,
    lower_cost = ifelse(filtered_df$multiplier < medium_bound, 30000, 
                        ifelse(filtered_df$multiplier <= high_bound, 40000, 60000)) * 1.6728
  )
  
  # Add the geometry column to the new dataframe
  pond_cost_stl$geometry <- filtered_df$geometry
  
  return(pond_cost_stl)
}

# Define the bounds for low, medium, and high multipliers
low_multiplier_bound <- 0
medium_multiplier_bound <- 0.4
high_multiplier_bound <- 1

# Call the function with the provided dataframe and custom bounds
pond_cost_stl_inflated_custom <- calculate_pond_cost_inflation_geometry_custom(
  hist_flood_stl_var_mult, low_multiplier_bound, medium_multiplier_bound, high_multiplier_bound)
```

Create a function that takes slope and width to determine stream energy
```{r}
## Make histogram of slope
hist(hist_flood_stl_var_mult$slope, main = "Histogram of Slope Column", xlab = "Slope Values")
## Define values for low, medium and high based on histogram
## Low <0.005
## Medium >0.005 and <0.015
## High >0.015
## Make histogram of width
hist(hist_flood_stl_var_mult$wint_width, main = "Histogram of Width Column", xlab = "Width Values")
## Define values for low, medium and high based on histogram
## Low <20
## Medium >20 and <70
## High >70
```

Need to define which energy levels are associated with each slope/width combo
---> did this in the google doc

ONE VALUE IS UNKNOWN???

```{r}
# Create a function to assign energy values based on slope and wint_width ranges
assign_energy_width <- function(input_df, low_slope_range, medium_slope_range, high_slope_range, low_wint_width_range, medium_wint_width_range, high_wint_width_range) {
  # Filter for hab_unit == Marsh
  filtered_df <- input_df %>% filter(hab_unit == "Marsh")
  
  # Create a new column "energy" based on conditions
  filtered_df <- filtered_df %>%
    mutate(energy = case_when(
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) ~ "Low",
      (slope >= low_slope_range[1] & slope <= medium_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) |
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= medium_wint_width_range[2]) |
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= high_wint_width_range[2]) |
      (slope >= low_slope_range[1] & slope <= medium_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= medium_wint_width_range[2]) |
      (slope >= medium_slope_range[1] & slope <= high_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= medium_wint_width_range[2]) ~ "Medium",
      (slope >= medium_slope_range[1] & slope <= high_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= high_wint_width_range[2]) |
      (slope >= medium_slope_range[1] & slope <= medium_slope_range[2] & 
       wint_width >= high_wint_width_range[1] & wint_width <= high_wint_width_range[2]) |
      (slope >= high_slope_range[1] & slope <= high_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= medium_wint_width_range[2]) |
      (slope >= high_slope_range[1] & slope <= high_slope_range[2] & 
       wint_width >= high_wint_width_range[1] & wint_width <= high_wint_width_range[2]) ~ "High",
      TRUE ~ "Unknown"  # Handle any other cases
    ))
  
  return(filtered_df)
}

# Call the function with the provided dataframe and numeric range bounds
low_slope_range <- c(0, 0.005)
medium_slope_range <- c(0.005, 0.015)
high_slope_range <- c(0.015, 20) #arbitrary large number
low_width_range <- c(0, 19)
medium_width_range <- c(20, 69)
high_width_range <- c(70, 300) #arbitrary large number

marsh_energy_stl <- assign_energy_width(hist_flood_stl_var_mult, low_slope_range, medium_slope_range, high_slope_range, low_width_range, medium_width_range, high_width_range)
```

Create a function that takes different multiplier values and energies and creates a upper and lower cost range