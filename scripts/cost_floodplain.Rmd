---
title: "cost_floodplain"
author: "Meghan Roberts"
date: "2023-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, include=FALSE, message = FALSE, error = FALSE)


#clearing environment
rm(list = ls())

#sourcing data
source("../common.R")
```







Remember to change the width value (as needed) and fix the matching between noaa_subba and reach_names.
Also change the low, medium and high division asscoiated with the multipliers


## Filtering floodplain data 
```{r}
## filtering for only floodplains that existed historically, but not currently
hist_flood_stl<-flood_stl %>% 
  filter(period=="Hist")

## filtering for specific columns to make the join cleaner
slope_width_stl<-flow_stl %>% 
  select(noaaid, slope, wint_width, pond_overl, chinook, noaa_subba) %>% 
  st_drop_geometry()

#change width as needed
## Join the floodplain habitats with the associated stream variables
hist_flood_stl_var<- left_join(hist_flood_stl, slope_width_stl, by = "noaaid")

#need to fix because not all reach names have noaa_subba matches
## Join the variables with the side channel multipliers
hist_flood_stl_var_mult<-left_join(hist_flood_stl_var, side_channel_mult_stl, by = c("noaa_subba"= "reach_name"))%>% 
  mutate(project_number = 1:n())

## Subtract one from multiplier column and do absolute value
hist_flood_stl_var_mult$multiplier<-abs(hist_flood_stl_var_mult$multiplier-1)

## Histogram of Multiplier Values
hist(hist_flood_stl_var_mult$multiplier, main = "Histogram of Multiplier Column", xlab = "Multiplier Values")

## Define values for low, medium and high based on histogram
## Low <0.4
## Medium >0.4 and <1
## High >1
```

Both ponds have a side channel multiplier of 0
Assumed substantial material cost for upper and lower cost estimates
Assumes inflation rate of 2.61% per year between 2003 and today, producing a cumulative price increase of 67.28% (https://www.officialdata.org/us/inflation/2003?amount=30000)

NEW ONE
```{r}
# Create a function to calculate cost estimates with inflation adjustment
calculate_pond_cost_inflation_geometry_custom <- function(input_df, low_bound, medium_bound, high_bound) {
  # Filter for hab_unit == Pond or Lake
  filtered_df <- input_df %>% filter(hab_unit %in% c("Pond", "Lake"))
  
  # Create a new dataframe
  pond_cost_stl <- data.frame(
    project_number = filtered_df$project_number,
    upper_cost = ifelse(filtered_df$multiplier < medium_bound, 40000, 
                        ifelse(filtered_df$multiplier <= high_bound, 60000, 80000)) * 1.6728,
    lower_cost = ifelse(filtered_df$multiplier < medium_bound, 30000, 
                        ifelse(filtered_df$multiplier <= high_bound, 40000, 60000)) * 1.6728
  )
  
  # Add the geometry and area column to the new dataframe
  pond_cost_stl$geometry <- filtered_df$geometry
  pond_cost_stl$area_ha <- filtered_df$area_ha
  
  return(pond_cost_stl)
}

# Define the bounds for low, medium, and high multipliers
low_multiplier_bound <- 0
medium_multiplier_bound <- 0.4
high_multiplier_bound <- 1

# Call the function with the provided dataframe and custom bounds
pond_cost_stl_inflated_custom <- calculate_pond_cost_inflation_geometry_custom(
  hist_flood_stl_var_mult, low_multiplier_bound, medium_multiplier_bound, high_multiplier_bound)

pond_cost_inflation <- pond_cost_stl_inflated_custom %>% 
  mutate(area_a=area_ha*2.47105) %>% 
  mutate(total_lower_cost=lower_cost*area_a) %>% 
  mutate(total_upper_cost=upper_cost*area_a)
```

Create a function that takes slope and width to determine stream energy
```{r}
## Make histogram of slope
hist(hist_flood_stl_var_mult$slope, main = "Histogram of Slope Column", xlab = "Slope Values")
## Define values for low, medium and high based on histogram
## Low <0.005
## Medium >0.005 and <0.015
## High >0.015
## Make histogram of width
hist(hist_flood_stl_var_mult$wint_width, main = "Histogram of Width Column", xlab = "Width Values")
## Define values for low, medium and high based on histogram
## Low <20
## Medium >20 and <70
## High >70
```

Need to define which energy levels are associated with each slope/width combo
---> did this in the google doc

ONE VALUE IS UNKNOWN???

```{r}
# Create a function to assign energy values based on slope and wint_width ranges
assign_energy_width <- function(input_df, low_slope_range, medium_slope_range, high_slope_range, low_wint_width_range, medium_wint_width_range, high_wint_width_range) {
  # Filter for hab_unit == Marsh
  filtered_df <- input_df %>% filter(hab_unit == "Marsh")
  
  # Create a new column "energy" based on conditions
  filtered_df <- filtered_df %>%
    mutate(energy = case_when(
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) ~ "low",
      (slope >= low_slope_range[1] & slope <= medium_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= low_wint_width_range[2]) |
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= low_wint_width_range[1] & wint_width <= medium_wint_width_range[2]) |
      (slope >= low_slope_range[1] & slope <= low_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= high_wint_width_range[2]) |
      (slope >= low_slope_range[1] & slope <= medium_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= medium_wint_width_range[2]) |
      (slope >= medium_slope_range[1] & slope <= high_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= medium_wint_width_range[2]) ~ "medium",
      (slope >= medium_slope_range[1] & slope <= high_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= high_wint_width_range[2]) |
      (slope >= medium_slope_range[1] & slope <= medium_slope_range[2] & 
       wint_width >= high_wint_width_range[1] & wint_width <= high_wint_width_range[2]) |
      (slope >= high_slope_range[1] & slope <= high_slope_range[2] & 
       wint_width >= medium_wint_width_range[1] & wint_width <= medium_wint_width_range[2]) |
      (slope >= high_slope_range[1] & slope <= high_slope_range[2] & 
       wint_width >= high_wint_width_range[1] & wint_width <= high_wint_width_range[2]) ~ "high",
      TRUE ~ "Unknown"  # Handle any other cases
    ))
  
  return(filtered_df)
}

# Call the function with the provided dataframe and numeric range bounds
low_slope_range <- c(0, 0.005)
medium_slope_range <- c(0.0051, 0.015)
high_slope_range <- c(0.0151, 20) #arbitrary large number
low_width_range <- c(0, 19)
medium_width_range <- c(20, 69)
high_width_range <- c(70, 300) #arbitrary large number

marsh_energy_stl <- assign_energy_width(hist_flood_stl_var_mult, low_slope_range, medium_slope_range, high_slope_range, low_width_range, medium_width_range, high_width_range)
```

Create a function that takes different multiplier values and energies and creates a upper and lower cost range

Currently using zero as a placeholder for when side channel multiplier values don't exist
```{r}
hist_flood_stl_var_mult<-hist_flood_stl_var_mult %>% 
  mutate(earth_moving=ifelse(multiplier < medium_multiplier_bound, "low", 
                        ifelse(multiplier <= high_multiplier_bound, "medium", "high")))

calculate_marsh_cost <- function(input_df) {
  input_df <- input_df %>%
    mutate(
      lower_cost = case_when(
        earth_moving == "low" & energy == "low" ~ 20000,
        earth_moving == "low" & energy == "medium" ~ 40000,
        earth_moving == "low" & energy == "high" ~ 60000,
        earth_moving == "medium" & energy == "low" ~ 40000,
        earth_moving == "medium" & energy == "medium" ~ 70000,
        earth_moving == "medium" & energy == "high" ~ 100000,
        earth_moving == "high" & energy == "low" ~ 60000,
        earth_moving == "high" & energy == "medium" ~ 130000,
        earth_moving == "high" & energy == "high" ~ 200000,
        # Add more conditions for other combinations here
        TRUE ~ 0  # Default value if no conditions match
      ),
      upper_cost = case_when(
        earth_moving == "low" & energy == "low" ~ 40000,
        earth_moving == "low" & energy == "medium" ~ 70000,
        earth_moving == "low" & energy == "high" ~ 90000,
        earth_moving == "medium" & energy == "low" ~ 60000,
        earth_moving == "medium" & energy == "medium" ~ 100000,
        earth_moving == "medium" & energy == "high" ~ 200000,
        earth_moving == "high" & energy == "low" ~ 100000,
        earth_moving == "high" & energy == "medium" ~ 200000,
        earth_moving == "high" & energy == "high" ~ 300000,
        # Add more conditions for other combinations here
        TRUE ~ 0  # Default value if no conditions match
      )
    )
  
  return(input_df)
}

marsh_cost <- calculate_marsh_cost(marsh_energy_stl)

## account for inflation and get area in acres to get total cost
marsh_cost_inflation <- marsh_cost %>% 
  mutate(lower_cost=lower_cost* 1.6728) %>% 
  mutate(upper_cost=upper_cost* 1.6728) %>% 
  mutate(area_a=area_ha*2.47105) %>% 
  mutate(total_lower_cost=lower_cost*area_a) %>% 
  mutate(total_upper_cost=upper_cost*area_a)
```

```{r}
marsh_cost_inflation_select<-marsh_cost_inflation %>% 
  select(geometry, project_number, total_lower_cost, total_upper_cost)
pond_cost_inflation_select<-pond_cost_inflation %>% 
  select(geometry, project_number, total_lower_cost, total_upper_cost)
stilli_total_cost<-full_join(marsh_cost_inflation_select, pond_cost_inflation_select) %>% 
  mutate(average_cost=(total_upper_cost+total_lower_cost)/2)
```

